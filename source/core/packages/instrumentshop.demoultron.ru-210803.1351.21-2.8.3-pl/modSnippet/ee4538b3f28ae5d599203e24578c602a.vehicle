<?php return array (
  'preserve_keys' => true,
  'update_object' => true,
  'vehicle_package' => 'transport',
  'vehicle_class' => 'xPDOObjectVehicle',
  'guid' => '08f3d719637bfa7d943a15605ceb699c',
  'package' => 'modx',
  'class' => 'modSnippet',
  'signature' => 'ee4538b3f28ae5d599203e24578c602a',
  'native_key' => 26,
  'object' => '{"id":26,"source":0,"property_preprocess":0,"name":"migxGetCollectionTree","description":"","editor_type":0,"category":3,"cache_type":0,"snippet":"\\/**\\n * migxGetCollectionTree\\n *\\n * Copyright 2014 by Bruno Perner <b.perner@gmx.de>\\n *\\n * migxGetCollectionTree is free software; you can redistribute it and\\/or modify it\\n * under the terms of the GNU General Public License as published by the Free\\n * Software Foundation; either version 2 of the License, or (at your option) any\\n * later version.\\n *\\n * migxGetCollectionTree is distributed in the hope that it will be useful, but WITHOUT ANY\\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License along with\\n * migxGetCollectionTree; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\\n * Suite 330, Boston, MA 02111-1307 USA\\n *\\n * @package migx\\n *\\/\\n\\/**\\n * migxGetCollectionTree\\n *\\n *          display nested items from different objects. The tree-schema is defined by a json-property. \\n *\\n * @version 1.0.0\\n * @author Bruno Perner <b.perner@gmx.de>\\n * @copyright Copyright &copy; 2014\\n * @license http:\\/\\/www.gnu.org\\/licenses\\/old-licenses\\/gpl-2.0.html GNU General Public License\\n * version 2 or (at your option) any later version.\\n * @package migx\\n *\\/\\n\\n$treeSchema = $modx->getOption(\'treeSchema\', $scriptProperties, \'\');\\n$treeSchema = $modx->fromJson($treeSchema);\\n\\n$scriptProperties[\'current\'] = $modx->getOption(\'current\', $scriptProperties, \'\');\\n$scriptProperties[\'currentClassname\'] = $modx->getOption(\'currentClassname\', $scriptProperties, \'\');\\n$scriptProperties[\'currentKeyField\'] = $modx->getOption(\'currentKeyField\', $scriptProperties, \'id\');\\n$return = $modx->getOption(\'return\', $scriptProperties, \'parsed\'); \\/\\/parsed,json,arrayprint\\n\\n\\/*\\nExamples:\\n\\nGet Resource-Tree, 4 levels deep\\n\\n[[!migxGetCollectionTree?\\n&current=`57`\\n&currentClassname=`modResource`\\n&treeSchema=`\\n{\\n\\"classname\\": \\"modResource\\",\\n\\"debug\\": \\"1\\",\\n\\"tpl\\": \\"mgctResourceTree\\",\\n\\"wrapperTpl\\": \\"@CODE:<ul>[[+output]]<\\/ul>\\",\\n\\"selectfields\\": \\"id,pagetitle\\",\\n\\"where\\": {\\n\\"parent\\": \\"0\\",\\n\\"published\\": \\"1\\",\\n\\"deleted\\": \\"0\\"\\n},\\n\\"_branches\\": [{\\n\\"alias\\": \\"children\\",\\n\\"classname\\": \\"modResource\\",\\n\\"local\\": \\"parent\\",\\n\\"foreign\\": \\"id\\",\\n\\"tpl\\": \\"mgctResourceTree\\",\\n\\"debug\\": \\"1\\",\\n\\"selectfields\\": \\"id,pagetitle,parent\\",\\n\\"_branches\\": [{\\n\\"alias\\": \\"children\\",\\n\\"classname\\": \\"modResource\\",\\n\\"local\\": \\"parent\\",\\n\\"foreign\\": \\"id\\",\\n\\"tpl\\": \\"mgctResourceTree\\",\\n\\"debug\\": \\"1\\",\\n\\"selectfields\\": \\"id,pagetitle,parent\\",\\n\\"where\\": {\\n\\"published\\": \\"1\\",\\n\\"deleted\\": \\"0\\"\\n},\\n\\"_branches\\": [{\\n\\"alias\\": \\"children\\",\\n\\"classname\\": \\"modResource\\",\\n\\"local\\": \\"parent\\",\\n\\"foreign\\": \\"id\\",\\n\\"tpl\\": \\"mgctResourceTree\\",\\n\\"debug\\": \\"1\\",\\n\\"selectfields\\": \\"id,pagetitle,parent\\",\\n\\"where\\": {\\n\\"published\\": \\"1\\",\\n\\"deleted\\": \\"0\\"\\n}\\n}]\\n}]\\n}]\\n}\\n`]]\\n\\nthe chunk mgctResourceTree:\\n<li class=\\"[[+_activelabel]] [[+_currentlabel]]\\" ><a href=\\"[[~[[+id]]]]\\">[[+pagetitle]]([[+id]])<\\/a><\\/li>\\n[[+innercounts.children:gt=`0`:then=`\\n<ul>[[+innerrows.children]]<\\/ul>\\n`:else=``]]\\n\\nget all Templates and its Resources:\\n\\n[[!migxGetCollectionTree?\\n&treeSchema=`\\n{\\n\\"classname\\": \\"modTemplate\\",\\n\\"debug\\": \\"1\\",\\n\\"tpl\\": \\"@CODE:<h3>[[+templatename]]<\\/h3><ul>[[+innerrows.resource]]<\\/ul>\\",\\n\\"selectfields\\": \\"id,templatename\\",\\n\\"_branches\\": [{\\n\\"alias\\": \\"resource\\",\\n\\"classname\\": \\"modResource\\",\\n\\"local\\": \\"template\\",\\n\\"foreign\\": \\"id\\",\\n\\"tpl\\": \\"@CODE:<li>[[+pagetitle]]([[+id]])<\\/li>\\",\\n\\"debug\\": \\"1\\",\\n\\"selectfields\\": \\"id,pagetitle,template\\"\\n}]\\n}\\n`]]\\n*\\/\\n\\nif (!class_exists(\'MigxGetCollectionTree\')) {\\n    class MigxGetCollectionTree\\n    {\\n        function __construct(modX & $modx, array $config = array())\\n        {\\n            $this->modx = &$modx;\\n            $this->config = $config;\\n        }\\n\\n        function getBranch($branch, $foreigns = array(), $level = 1)\\n        {\\n\\n            $rows = array();\\n\\n            if (count($foreigns) > 0) {\\n                $modx = &$this->modx;\\n\\n                $local = $modx->getOption(\'local\', $branch, \'\');\\n                $where = $modx->getOption(\'where\', $branch, array());\\n                $where = !empty($where) && !is_array($where) ? $modx->fromJSON($where) : $where;\\n                $where[] = array($local . \':IN\' => $foreigns);\\n\\n                $branch[\'where\'] = $modx->toJson($where);\\n\\n                $level++;\\n                \\/*\\n                if ($levelFromCurrent > 0){\\n                $levelFromCurrent++;    \\n                }\\n                *\\/\\n\\n                $rows = $this->getRows($branch, $level);\\n            }\\n\\n            return $rows;\\n        }\\n\\n        function getRows($scriptProperties, $level)\\n        {\\n            $migx = &$this->migx;\\n            $modx = &$this->modx;\\n\\n            $current = $modx->getOption(\'current\', $this->config, \'\');\\n            $currentKeyField = $modx->getOption(\'currentKeyField\', $this->config, \'id\');\\n            $currentlabel = $modx->getOption(\'currentlabel\', $this->config, \'current\');\\n            $classname = $modx->getOption(\'classname\', $scriptProperties, \'\');\\n\\t\\t\\t$sortResult = $modx->getOption(\'sortResult\', $scriptProperties, \'\');\\n            $currentClassname = !empty($this->config[\'currentClassname\']) ? $this->config[\'currentClassname\'] : $classname;\\n\\n            $activelabel = $modx->getOption(\'activelabel\', $this->config, \'active\');\\n            $return = $modx->getOption(\'return\', $this->config, \'parsed\');\\n\\n            $xpdo = $migx->getXpdoInstanceAndAddPackage($scriptProperties);\\n            $c = $migx->prepareQuery($xpdo, $scriptProperties);\\n            $rows = $migx->getCollection($c);\\n\\n            $branches = $modx->getOption(\'_branches\', $scriptProperties, array());\\n\\n            $collectedSubrows = array();\\n            foreach ($branches as $branch) {\\n                $foreign = $modx->getOption(\'foreign\', $branch, \'\');\\n                $local = $modx->getOption(\'local\', $branch, \'\');\\n                $alias = $modx->getOption(\'alias\', $branch, \'\');\\n                \\/\\/$activeonly = $modx->getOption(\'activeonly\', $branch, \'\');\\n                $foreigns = array();\\n                foreach ($rows as $row) {\\n                    $foreigns[] = $row[$foreign];\\n                }\\n\\n                $subrows = $this->getBranch($branch, $foreigns, $level);\\n                foreach ($subrows as $subrow) {\\n\\n                    $collectedSubrows[$subrow[$local]][] = $subrow;\\n                    $subrow[\'_active\'] = $modx->getOption(\'_active\', $subrow, \'0\');\\n                    \\/*\\n                    if (!empty($activeonly) && $subrow[\'_active\'] != \'1\') {\\n                    $output = \'\';\\n                    } else {\\n                    $collectedSubrows[$subrow[$local]][] = $subrow;\\n                    }\\n                    *\\/\\n                    if ($subrow[\'_active\'] == \'1\') {\\n                        \\/\\/echo \'active subrow:<pre>\' . print_r($subrow,1) . \'<\\/pre>\';\\n                        $activesubrow[$subrow[$local]] = true;\\n                    }\\n                    if ($subrow[\'_current\'] == \'1\') {\\n                        \\/\\/echo \'active subrow:<pre>\' . print_r($subrow,1) . \'<\\/pre>\';\\n                        $currentsubrow[$subrow[$local]] = true;\\n                    }\\n\\n\\n                }\\n                \\/\\/insert subrows\\n                $temprows = $rows;\\n                $rows = array();\\n                foreach ($temprows as $row) {\\n                    if (isset($collectedSubrows[$row[$foreign]])) {\\n                        $row[\'_active\'] = \'0\';\\n                        $row[\'_currentparent\'] = \'0\';\\n                        if (isset($activesubrow[$row[$foreign]]) && $activesubrow[$row[$foreign]]) {\\n                            $row[\'_active\'] = \'1\';\\n                            \\/\\/echo \'active row:<pre>\' . print_r($row,1) . \'<\\/pre>\';\\n                        }\\n                        if (isset($currentsubrow[$row[$foreign]]) && $currentsubrow[$row[$foreign]]) {\\n                            $row[\'_currentparent\'] = \'1\';\\n                            \\/\\/echo \'active row:<pre>\' . print_r($row,1) . \'<\\/pre>\';\\n                        }\\n\\n                        \\/\\/render innerrows\\n                        \\/\\/$output = $migx->renderOutput($collectedSubrows[$row[$foreign]],$scriptProperties);\\n                        \\/\\/$output = $collectedSubrows[$row[$foreign]];\\n\\n                        $row[\'innercounts.\' . $alias] = count($collectedSubrows[$row[$foreign]]);\\n                        $row[\'_scriptProperties\'][$alias] = $branch;\\n                        \\/*\\n                        switch ($return) {\\n                        case \'parsed\':\\n                        $output = $migx->renderOutput($collectedSubrows[$row[$foreign]], $branch);\\n                        \\/\\/$subbranches = $modx->getOption(\'_branches\', $branch, array());\\n                        \\/\\/if there are any placeholders left with the same alias from subbranch, remove them\\n                        $output = str_replace(\'[[+innerrows.\' . $alias . \']]\', \'\', $output);\\n                        break;\\n                        case \'json\':\\n                        case \'arrayprint\':\\n                        $output = $collectedSubrows[$row[$foreign]];\\n                        break;\\n                        }\\n                        *\\/\\n                        $output = $collectedSubrows[$row[$foreign]];\\n\\n                        $row[\'innerrows.\' . $alias] = $output;\\n\\n                    }\\n                    $rows[] = $row;\\n                }\\n\\n            }\\n\\n            $temprows = $rows;\\n            $rows = array();\\n            foreach ($temprows as $row) {\\n                \\/\\/add additional placeholders\\n                $row[\'_level\'] = $level;\\n                $row[\'_active\'] = $modx->getOption(\'_active\', $row, \'0\');\\n                if ($currentClassname == $classname && $row[$currentKeyField] == $current) {\\n                    $row[\'_current\'] = \'1\';\\n                    $row[\'_currentlabel\'] = $currentlabel;\\n                    $row[\'_active\'] = \'1\';\\n                } else {\\n                    $row[\'_current\'] = \'0\';\\n                    $row[\'_currentlabel\'] = \'\';\\n                }\\n                if ($row[\'_active\'] == \'1\') {\\n                    $row[\'_activelabel\'] = $activelabel;\\n                } else {\\n                    $row[\'_activelabel\'] = \'\';\\n                }\\n                $rows[] = $row;\\n            }\\n\\n            if (!empty($sortResult) && is_array($sortResult)){\\n                $rows = $migx->sortDbResult($rows, $sortResult);\\n\\t\\t\\t}\\n\\n            return $rows;\\n        }\\n\\n        function renderRow($row, $levelFromCurrent = 0)\\n        {\\n            $migx = &$this->migx;\\n            $modx = &$this->modx;\\n            $return = $modx->getOption(\'return\', $this->config, \'parsed\');\\n            $branchProperties = $modx->getOption(\'_scriptProperties\', $row, array());\\n            $current = $modx->getOption(\'_current\', $row, \'0\');\\n            $currentparent = $modx->getOption(\'_currentparent\', $row, \'0\');\\n            $levelFromCurrent = $current == \'1\' ? 1 : $levelFromCurrent;\\n            $row[\'_levelFromCurrent\'] = $levelFromCurrent;\\n            foreach ($branchProperties as $alias => $properties) {\\n                $innerrows = $modx->getOption(\'innerrows.\' . $alias, $row, array());\\n                $subrows = $this->renderRows($innerrows, $properties, $levelFromCurrent, $currentparent);\\n                if ($return == \'parsed\') {\\n                    $subrows = $migx->renderOutput($subrows, $properties);\\n                }\\n                $row[\'innerrows.\' . $alias] = $subrows;\\n            }\\n\\n            return $row;\\n        }\\n\\n        function renderRows($rows, $scriptProperties, $levelFromCurrent = 0, $siblingOfCurrent = \'0\')\\n        {\\n\\n            $modx = &$this->modx;\\n            $temprows = $rows;\\n            $rows = array();\\n            if ($levelFromCurrent > 0) {\\n                $levelFromCurrent++;\\n            }\\n            foreach ($temprows as $row) {\\n                $row[\'_siblingOfCurrent\'] = $siblingOfCurrent;\\n                $row = $this->renderRow($row, $levelFromCurrent);\\n                $rows[] = $row;\\n            }\\n            return $rows;\\n        }\\n    }\\n}\\n\\n$instance = new MigxGetCollectionTree($modx, $scriptProperties);\\n\\nif (is_array($treeSchema)) {\\n    $scriptProperties = $treeSchema;\\n\\n    $migx = $modx->getService(\'migx\', \'Migx\', $modx->getOption(\'migx.core_path\', null, $modx->getOption(\'core_path\') . \'components\\/migx\\/\') . \'model\\/migx\\/\', $scriptProperties);\\n    if (!($migx instanceof Migx))\\n        return \'\';\\n\\n    $defaultcontext = \'web\';\\n    $migx->working_context = isset($modx->resource) ? $modx->resource->get(\'context_key\') : $defaultcontext;\\n    $instance->migx = &$migx;\\n\\n    $level = 1;\\n    $scriptProperties[\'alias\'] = \'row\';\\n    $rows = $instance->getRows($scriptProperties, $level);\\n\\n    $row = array();\\n    $row[\'innercounts.row\'] = count($rows);\\n    $row[\'innerrows.row\'] = $rows;\\n    $row[\'_scriptProperties\'][\'row\'] = $scriptProperties;\\n\\n    $rows = $instance->renderRow($row);\\n\\n    $output = \'\';\\n    switch ($return) {\\n        case \'parsed\':\\n            $output = $modx->getOption(\'innerrows.row\', $rows, \'\');\\n            break;\\n        case \'json\':\\n            $output = $modx->toJson($rows);\\n            break;\\n        case \'arrayprint\':\\n            $output = \'<pre>\' . print_r($rows, 1) . \'<\\/pre>\';\\n            break;\\n    }\\n\\n    return $output;\\n\\n}","locked":0,"properties":"a:0:{}","moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * migxGetCollectionTree\\n *\\n * Copyright 2014 by Bruno Perner <b.perner@gmx.de>\\n *\\n * migxGetCollectionTree is free software; you can redistribute it and\\/or modify it\\n * under the terms of the GNU General Public License as published by the Free\\n * Software Foundation; either version 2 of the License, or (at your option) any\\n * later version.\\n *\\n * migxGetCollectionTree is distributed in the hope that it will be useful, but WITHOUT ANY\\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License along with\\n * migxGetCollectionTree; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\\n * Suite 330, Boston, MA 02111-1307 USA\\n *\\n * @package migx\\n *\\/\\n\\/**\\n * migxGetCollectionTree\\n *\\n *          display nested items from different objects. The tree-schema is defined by a json-property. \\n *\\n * @version 1.0.0\\n * @author Bruno Perner <b.perner@gmx.de>\\n * @copyright Copyright &copy; 2014\\n * @license http:\\/\\/www.gnu.org\\/licenses\\/old-licenses\\/gpl-2.0.html GNU General Public License\\n * version 2 or (at your option) any later version.\\n * @package migx\\n *\\/\\n\\n$treeSchema = $modx->getOption(\'treeSchema\', $scriptProperties, \'\');\\n$treeSchema = $modx->fromJson($treeSchema);\\n\\n$scriptProperties[\'current\'] = $modx->getOption(\'current\', $scriptProperties, \'\');\\n$scriptProperties[\'currentClassname\'] = $modx->getOption(\'currentClassname\', $scriptProperties, \'\');\\n$scriptProperties[\'currentKeyField\'] = $modx->getOption(\'currentKeyField\', $scriptProperties, \'id\');\\n$return = $modx->getOption(\'return\', $scriptProperties, \'parsed\'); \\/\\/parsed,json,arrayprint\\n\\n\\/*\\nExamples:\\n\\nGet Resource-Tree, 4 levels deep\\n\\n[[!migxGetCollectionTree?\\n&current=`57`\\n&currentClassname=`modResource`\\n&treeSchema=`\\n{\\n\\"classname\\": \\"modResource\\",\\n\\"debug\\": \\"1\\",\\n\\"tpl\\": \\"mgctResourceTree\\",\\n\\"wrapperTpl\\": \\"@CODE:<ul>[[+output]]<\\/ul>\\",\\n\\"selectfields\\": \\"id,pagetitle\\",\\n\\"where\\": {\\n\\"parent\\": \\"0\\",\\n\\"published\\": \\"1\\",\\n\\"deleted\\": \\"0\\"\\n},\\n\\"_branches\\": [{\\n\\"alias\\": \\"children\\",\\n\\"classname\\": \\"modResource\\",\\n\\"local\\": \\"parent\\",\\n\\"foreign\\": \\"id\\",\\n\\"tpl\\": \\"mgctResourceTree\\",\\n\\"debug\\": \\"1\\",\\n\\"selectfields\\": \\"id,pagetitle,parent\\",\\n\\"_branches\\": [{\\n\\"alias\\": \\"children\\",\\n\\"classname\\": \\"modResource\\",\\n\\"local\\": \\"parent\\",\\n\\"foreign\\": \\"id\\",\\n\\"tpl\\": \\"mgctResourceTree\\",\\n\\"debug\\": \\"1\\",\\n\\"selectfields\\": \\"id,pagetitle,parent\\",\\n\\"where\\": {\\n\\"published\\": \\"1\\",\\n\\"deleted\\": \\"0\\"\\n},\\n\\"_branches\\": [{\\n\\"alias\\": \\"children\\",\\n\\"classname\\": \\"modResource\\",\\n\\"local\\": \\"parent\\",\\n\\"foreign\\": \\"id\\",\\n\\"tpl\\": \\"mgctResourceTree\\",\\n\\"debug\\": \\"1\\",\\n\\"selectfields\\": \\"id,pagetitle,parent\\",\\n\\"where\\": {\\n\\"published\\": \\"1\\",\\n\\"deleted\\": \\"0\\"\\n}\\n}]\\n}]\\n}]\\n}\\n`]]\\n\\nthe chunk mgctResourceTree:\\n<li class=\\"[[+_activelabel]] [[+_currentlabel]]\\" ><a href=\\"[[~[[+id]]]]\\">[[+pagetitle]]([[+id]])<\\/a><\\/li>\\n[[+innercounts.children:gt=`0`:then=`\\n<ul>[[+innerrows.children]]<\\/ul>\\n`:else=``]]\\n\\nget all Templates and its Resources:\\n\\n[[!migxGetCollectionTree?\\n&treeSchema=`\\n{\\n\\"classname\\": \\"modTemplate\\",\\n\\"debug\\": \\"1\\",\\n\\"tpl\\": \\"@CODE:<h3>[[+templatename]]<\\/h3><ul>[[+innerrows.resource]]<\\/ul>\\",\\n\\"selectfields\\": \\"id,templatename\\",\\n\\"_branches\\": [{\\n\\"alias\\": \\"resource\\",\\n\\"classname\\": \\"modResource\\",\\n\\"local\\": \\"template\\",\\n\\"foreign\\": \\"id\\",\\n\\"tpl\\": \\"@CODE:<li>[[+pagetitle]]([[+id]])<\\/li>\\",\\n\\"debug\\": \\"1\\",\\n\\"selectfields\\": \\"id,pagetitle,template\\"\\n}]\\n}\\n`]]\\n*\\/\\n\\nif (!class_exists(\'MigxGetCollectionTree\')) {\\n    class MigxGetCollectionTree\\n    {\\n        function __construct(modX & $modx, array $config = array())\\n        {\\n            $this->modx = &$modx;\\n            $this->config = $config;\\n        }\\n\\n        function getBranch($branch, $foreigns = array(), $level = 1)\\n        {\\n\\n            $rows = array();\\n\\n            if (count($foreigns) > 0) {\\n                $modx = &$this->modx;\\n\\n                $local = $modx->getOption(\'local\', $branch, \'\');\\n                $where = $modx->getOption(\'where\', $branch, array());\\n                $where = !empty($where) && !is_array($where) ? $modx->fromJSON($where) : $where;\\n                $where[] = array($local . \':IN\' => $foreigns);\\n\\n                $branch[\'where\'] = $modx->toJson($where);\\n\\n                $level++;\\n                \\/*\\n                if ($levelFromCurrent > 0){\\n                $levelFromCurrent++;    \\n                }\\n                *\\/\\n\\n                $rows = $this->getRows($branch, $level);\\n            }\\n\\n            return $rows;\\n        }\\n\\n        function getRows($scriptProperties, $level)\\n        {\\n            $migx = &$this->migx;\\n            $modx = &$this->modx;\\n\\n            $current = $modx->getOption(\'current\', $this->config, \'\');\\n            $currentKeyField = $modx->getOption(\'currentKeyField\', $this->config, \'id\');\\n            $currentlabel = $modx->getOption(\'currentlabel\', $this->config, \'current\');\\n            $classname = $modx->getOption(\'classname\', $scriptProperties, \'\');\\n\\t\\t\\t$sortResult = $modx->getOption(\'sortResult\', $scriptProperties, \'\');\\n            $currentClassname = !empty($this->config[\'currentClassname\']) ? $this->config[\'currentClassname\'] : $classname;\\n\\n            $activelabel = $modx->getOption(\'activelabel\', $this->config, \'active\');\\n            $return = $modx->getOption(\'return\', $this->config, \'parsed\');\\n\\n            $xpdo = $migx->getXpdoInstanceAndAddPackage($scriptProperties);\\n            $c = $migx->prepareQuery($xpdo, $scriptProperties);\\n            $rows = $migx->getCollection($c);\\n\\n            $branches = $modx->getOption(\'_branches\', $scriptProperties, array());\\n\\n            $collectedSubrows = array();\\n            foreach ($branches as $branch) {\\n                $foreign = $modx->getOption(\'foreign\', $branch, \'\');\\n                $local = $modx->getOption(\'local\', $branch, \'\');\\n                $alias = $modx->getOption(\'alias\', $branch, \'\');\\n                \\/\\/$activeonly = $modx->getOption(\'activeonly\', $branch, \'\');\\n                $foreigns = array();\\n                foreach ($rows as $row) {\\n                    $foreigns[] = $row[$foreign];\\n                }\\n\\n                $subrows = $this->getBranch($branch, $foreigns, $level);\\n                foreach ($subrows as $subrow) {\\n\\n                    $collectedSubrows[$subrow[$local]][] = $subrow;\\n                    $subrow[\'_active\'] = $modx->getOption(\'_active\', $subrow, \'0\');\\n                    \\/*\\n                    if (!empty($activeonly) && $subrow[\'_active\'] != \'1\') {\\n                    $output = \'\';\\n                    } else {\\n                    $collectedSubrows[$subrow[$local]][] = $subrow;\\n                    }\\n                    *\\/\\n                    if ($subrow[\'_active\'] == \'1\') {\\n                        \\/\\/echo \'active subrow:<pre>\' . print_r($subrow,1) . \'<\\/pre>\';\\n                        $activesubrow[$subrow[$local]] = true;\\n                    }\\n                    if ($subrow[\'_current\'] == \'1\') {\\n                        \\/\\/echo \'active subrow:<pre>\' . print_r($subrow,1) . \'<\\/pre>\';\\n                        $currentsubrow[$subrow[$local]] = true;\\n                    }\\n\\n\\n                }\\n                \\/\\/insert subrows\\n                $temprows = $rows;\\n                $rows = array();\\n                foreach ($temprows as $row) {\\n                    if (isset($collectedSubrows[$row[$foreign]])) {\\n                        $row[\'_active\'] = \'0\';\\n                        $row[\'_currentparent\'] = \'0\';\\n                        if (isset($activesubrow[$row[$foreign]]) && $activesubrow[$row[$foreign]]) {\\n                            $row[\'_active\'] = \'1\';\\n                            \\/\\/echo \'active row:<pre>\' . print_r($row,1) . \'<\\/pre>\';\\n                        }\\n                        if (isset($currentsubrow[$row[$foreign]]) && $currentsubrow[$row[$foreign]]) {\\n                            $row[\'_currentparent\'] = \'1\';\\n                            \\/\\/echo \'active row:<pre>\' . print_r($row,1) . \'<\\/pre>\';\\n                        }\\n\\n                        \\/\\/render innerrows\\n                        \\/\\/$output = $migx->renderOutput($collectedSubrows[$row[$foreign]],$scriptProperties);\\n                        \\/\\/$output = $collectedSubrows[$row[$foreign]];\\n\\n                        $row[\'innercounts.\' . $alias] = count($collectedSubrows[$row[$foreign]]);\\n                        $row[\'_scriptProperties\'][$alias] = $branch;\\n                        \\/*\\n                        switch ($return) {\\n                        case \'parsed\':\\n                        $output = $migx->renderOutput($collectedSubrows[$row[$foreign]], $branch);\\n                        \\/\\/$subbranches = $modx->getOption(\'_branches\', $branch, array());\\n                        \\/\\/if there are any placeholders left with the same alias from subbranch, remove them\\n                        $output = str_replace(\'[[+innerrows.\' . $alias . \']]\', \'\', $output);\\n                        break;\\n                        case \'json\':\\n                        case \'arrayprint\':\\n                        $output = $collectedSubrows[$row[$foreign]];\\n                        break;\\n                        }\\n                        *\\/\\n                        $output = $collectedSubrows[$row[$foreign]];\\n\\n                        $row[\'innerrows.\' . $alias] = $output;\\n\\n                    }\\n                    $rows[] = $row;\\n                }\\n\\n            }\\n\\n            $temprows = $rows;\\n            $rows = array();\\n            foreach ($temprows as $row) {\\n                \\/\\/add additional placeholders\\n                $row[\'_level\'] = $level;\\n                $row[\'_active\'] = $modx->getOption(\'_active\', $row, \'0\');\\n                if ($currentClassname == $classname && $row[$currentKeyField] == $current) {\\n                    $row[\'_current\'] = \'1\';\\n                    $row[\'_currentlabel\'] = $currentlabel;\\n                    $row[\'_active\'] = \'1\';\\n                } else {\\n                    $row[\'_current\'] = \'0\';\\n                    $row[\'_currentlabel\'] = \'\';\\n                }\\n                if ($row[\'_active\'] == \'1\') {\\n                    $row[\'_activelabel\'] = $activelabel;\\n                } else {\\n                    $row[\'_activelabel\'] = \'\';\\n                }\\n                $rows[] = $row;\\n            }\\n\\n            if (!empty($sortResult) && is_array($sortResult)){\\n                $rows = $migx->sortDbResult($rows, $sortResult);\\n\\t\\t\\t}\\n\\n            return $rows;\\n        }\\n\\n        function renderRow($row, $levelFromCurrent = 0)\\n        {\\n            $migx = &$this->migx;\\n            $modx = &$this->modx;\\n            $return = $modx->getOption(\'return\', $this->config, \'parsed\');\\n            $branchProperties = $modx->getOption(\'_scriptProperties\', $row, array());\\n            $current = $modx->getOption(\'_current\', $row, \'0\');\\n            $currentparent = $modx->getOption(\'_currentparent\', $row, \'0\');\\n            $levelFromCurrent = $current == \'1\' ? 1 : $levelFromCurrent;\\n            $row[\'_levelFromCurrent\'] = $levelFromCurrent;\\n            foreach ($branchProperties as $alias => $properties) {\\n                $innerrows = $modx->getOption(\'innerrows.\' . $alias, $row, array());\\n                $subrows = $this->renderRows($innerrows, $properties, $levelFromCurrent, $currentparent);\\n                if ($return == \'parsed\') {\\n                    $subrows = $migx->renderOutput($subrows, $properties);\\n                }\\n                $row[\'innerrows.\' . $alias] = $subrows;\\n            }\\n\\n            return $row;\\n        }\\n\\n        function renderRows($rows, $scriptProperties, $levelFromCurrent = 0, $siblingOfCurrent = \'0\')\\n        {\\n\\n            $modx = &$this->modx;\\n            $temprows = $rows;\\n            $rows = array();\\n            if ($levelFromCurrent > 0) {\\n                $levelFromCurrent++;\\n            }\\n            foreach ($temprows as $row) {\\n                $row[\'_siblingOfCurrent\'] = $siblingOfCurrent;\\n                $row = $this->renderRow($row, $levelFromCurrent);\\n                $rows[] = $row;\\n            }\\n            return $rows;\\n        }\\n    }\\n}\\n\\n$instance = new MigxGetCollectionTree($modx, $scriptProperties);\\n\\nif (is_array($treeSchema)) {\\n    $scriptProperties = $treeSchema;\\n\\n    $migx = $modx->getService(\'migx\', \'Migx\', $modx->getOption(\'migx.core_path\', null, $modx->getOption(\'core_path\') . \'components\\/migx\\/\') . \'model\\/migx\\/\', $scriptProperties);\\n    if (!($migx instanceof Migx))\\n        return \'\';\\n\\n    $defaultcontext = \'web\';\\n    $migx->working_context = isset($modx->resource) ? $modx->resource->get(\'context_key\') : $defaultcontext;\\n    $instance->migx = &$migx;\\n\\n    $level = 1;\\n    $scriptProperties[\'alias\'] = \'row\';\\n    $rows = $instance->getRows($scriptProperties, $level);\\n\\n    $row = array();\\n    $row[\'innercounts.row\'] = count($rows);\\n    $row[\'innerrows.row\'] = $rows;\\n    $row[\'_scriptProperties\'][\'row\'] = $scriptProperties;\\n\\n    $rows = $instance->renderRow($row);\\n\\n    $output = \'\';\\n    switch ($return) {\\n        case \'parsed\':\\n            $output = $modx->getOption(\'innerrows.row\', $rows, \'\');\\n            break;\\n        case \'json\':\\n            $output = $modx->toJson($rows);\\n            break;\\n        case \'arrayprint\':\\n            $output = \'<pre>\' . print_r($rows, 1) . \'<\\/pre>\';\\n            break;\\n    }\\n\\n    return $output;\\n\\n}"}',
);