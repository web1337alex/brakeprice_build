<?php return array (
  'preserve_keys' => true,
  'update_object' => true,
  'vehicle_package' => 'transport',
  'vehicle_class' => 'xPDOObjectVehicle',
  'guid' => '6e67947ad753102b51d855b1205240ef',
  'package' => 'modx',
  'class' => 'modSnippet',
  'signature' => 'ef39b0470b8a5484174b1a8601cfe9b8',
  'native_key' => 20,
  'object' => '{"id":20,"source":0,"property_preprocess":0,"name":"getDayliMIGXrecord","description":"","editor_type":0,"category":3,"cache_type":0,"snippet":"\\/**\\n * getDayliMIGXrecord\\n *\\n * Copyright 2009-2011 by Bruno Perner <b.perner@gmx.de>\\n *\\n * getDayliMIGXrecord is free software; you can redistribute it and\\/or modify it\\n * under the terms of the GNU General Public License as published by the Free\\n * Software Foundation; either version 2 of the License, or (at your option) any\\n * later version.\\n *\\n * getDayliMIGXrecord is distributed in the hope that it will be useful, but WITHOUT ANY\\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License along with\\n * getDayliMIGXrecord; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\\n * Suite 330, Boston, MA 02111-1307 USA\\n *\\n * @package migx\\n *\\/\\n\\/**\\n * getDayliMIGXrecord\\n *\\n * display Items from outputvalue of TV with custom-TV-input-type MIGX or from other JSON-string for MODx Revolution \\n *\\n * @version 1.0\\n * @author Bruno Perner <b.perner@gmx.de>\\n * @copyright Copyright &copy; 2012\\n * @license http:\\/\\/www.gnu.org\\/licenses\\/old-licenses\\/gpl-2.0.html GNU General Public License\\n * version 2 or (at your option) any later version.\\n * @package migx\\n *\\/\\n\\n\\/*example: [[!getDayliMIGXrecord? &tvname=`myTV`&tpl=`@CODE:<img src=\\"[[+image]]\\"\\/>` &randomize=`1`]]*\\/\\n\\/* get default properties *\\/\\n\\n\\n$tvname = $modx->getOption(\'tvname\', $scriptProperties, \'\');\\n$tpl = $modx->getOption(\'tpl\', $scriptProperties, \'\');\\n$randomize = $modx->getOption(\'randomize\', $scriptProperties, false);\\n$where = $modx->getOption(\'where\', $scriptProperties, \'\');\\n$where = !empty($where) ? $modx->fromJSON($where) : array();\\n$sort = $modx->getOption(\'sort\', $scriptProperties, \'\');\\n$sort = !empty($sort) ? $modx->fromJSON($sort) : array();\\n$toPlaceholder = $modx->getOption(\'toPlaceholder\', $scriptProperties, false);\\n$docid = $modx->getOption(\'docid\', $scriptProperties, (isset($modx->resource) ? $modx->resource->get(\'id\') : 1));\\n$processTVs = $modx->getOption(\'processTVs\', $scriptProperties, \'1\');\\n\\n$migx = $modx->getService(\'migx\', \'Migx\', $modx->getOption(\'migx.core_path\', null, $modx->getOption(\'core_path\') . \'components\\/migx\\/\') . \'model\\/migx\\/\', $scriptProperties);\\nif (!($migx instanceof Migx))\\n    return \'\';\\n$migx->working_context = $modx->resource->get(\'context_key\');\\n\\nif (!empty($tvname)) {\\n    if ($tv = $modx->getObject(\'modTemplateVar\', array(\'name\' => $tvname))) {\\n\\n        \\/*\\n        *   get inputProperties\\n        *\\/\\n\\n\\n        $properties = $tv->get(\'input_properties\');\\n        $properties = isset($properties[\'formtabs\']) ? $properties : $tv->getProperties();\\n\\n        $migx->config[\'configs\'] = $properties[\'configs\'];\\n        $migx->loadConfigs();\\n        \\/\\/ get tabs from file or migx-config-table\\n        $formtabs = $migx->getTabs();\\n        if (empty($formtabs)) {\\n            \\/\\/try to get formtabs and its fields from properties\\n            $formtabs = $modx->fromJSON($properties[\'formtabs\']);\\n        }\\n\\n        \\/\\/$tv->setCacheable(false);\\n        \\/\\/$outputvalue = $tv->renderOutput($docid);\\n        \\n        $tvresource = $modx->getObject(\'modTemplateVarResource\', array(\\n            \'tmplvarid\' => $tv->get(\'id\'),\\n            \'contentid\' => $docid,\\n            ));\\n\\n\\n        $outputvalue = $tvresource->get(\'value\');\\n        \\n        \\/*\\n        *   get inputTvs \\n        *\\/\\n        $inputTvs = array();\\n        if (is_array($formtabs)) {\\n\\n            \\/\\/multiple different Forms\\n            \\/\\/ Note: use same field-names and inputTVs in all forms\\n            $inputTvs = $migx->extractInputTvs($formtabs);\\n        }\\n        $migx->source = $tv->getSource($migx->working_context, false);\\n\\n        if (empty($outputvalue)) {\\n            return \'\';\\n        }\\n\\n        $items = $modx->fromJSON($outputvalue);\\n\\n\\n        \\/\\/is there an active item for the current date?\\n        $activedate = $modx->getOption(\'activedate\', $scriptProperties, strftime(\'%Y\\/%m\\/%d\'));\\n        \\/\\/$activedate = $modx->getOption(\'activedate\', $_GET, strftime(\'%Y\\/%m\\/%d\'));\\n        $activewhere = array();\\n        $activewhere[\'activedate\'] = $activedate;\\n        $activewhere[\'activated\'] = \'1\';\\n        $activeitems = $migx->filterItems($activewhere, $items);\\n\\n        if (count($activeitems) == 0) {\\n\\n            $activeitems = array();\\n            \\/\\/ where filter\\n            if (is_array($where) && count($where) > 0) {\\n                $items = $migx->filterItems($where, $items);\\n            }\\n\\n            $tempitems = array();\\n            $count = count($items);\\n            $emptycount = 0;\\n            $latestdate = $activedate;\\n            $nextdate = strtotime($latestdate);\\n            foreach ($items as $item) {\\n                \\/\\/empty all dates and active-states which are older than today\\n                if (!empty($item[\'activedate\']) && $item[\'activedate\'] < $activedate) {\\n                    $item[\'activated\'] = \'0\';\\n                    $item[\'activedate\'] = \'\';\\n                }\\n                if (empty($item[\'activedate\'])) {\\n                    $emptycount++;\\n                }\\n                if ($item[\'activedate\'] > $latestdate) {\\n                    $latestdate = $item[\'activedate\'];\\n                    $nextdate = strtotime($latestdate) + (24 * 60 * 60);\\n                }\\n                if ($item[\'activedate\'] == $activedate) {\\n                    $item[\'activated\'] = \'1\';\\n                    $activeitems[] = $item;\\n                }\\n                $tempitems[] = $item;\\n            }\\n\\n            \\/\\/echo \'<pre>\' . print_r($tempitems, 1) . \'<\\/pre>\';\\n\\n            $items = $tempitems;\\n\\n\\n            \\/\\/are there more than half of all items with empty activedates\\n\\n            if ($emptycount >= $count \\/ 2) {\\n\\n                \\/\\/ sort items\\n                if (is_array($sort) && count($sort) > 0) {\\n                    $items = $migx->sortDbResult($items, $sort);\\n                }\\n                if (count($items) > 0) {\\n                    \\/\\/shuffle items\\n                    if ($randomize) {\\n                        shuffle($items);\\n                    }\\n                }\\n\\n                $tempitems = array();\\n                foreach ($items as $item) {\\n                    if (empty($item[\'activedate\'])) {\\n                        $item[\'activedate\'] = strftime(\'%Y\\/%m\\/%d\', $nextdate);\\n                        $nextdate = $nextdate + (24 * 60 * 60);\\n                        if ($item[\'activedate\'] == $activedate) {\\n                            $item[\'activated\'] = \'1\';\\n                            $activeitems[] = $item;\\n                        }\\n                    }\\n\\n                    $tempitems[] = $item;\\n                }\\n\\n                $items = $tempitems;\\n            }\\n\\n            \\/\\/$resource = $modx->getObject(\'modResource\', $docid);\\n            \\/\\/echo $modx->toJson($items);\\n            $sort = \'[{\\"sortby\\":\\"activedate\\"}]\';\\n            $items = $migx->sortDbResult($items, $modx->fromJson($sort));\\n\\n            \\/\\/echo \'<pre>\' . print_r($items, 1) . \'<\\/pre>\';\\n\\n            $tv->setValue($docid, $modx->toJson($items));\\n            $tv->save();\\n\\n        }\\n    }\\n\\n}\\n\\n\\n$properties = array();\\nforeach ($scriptProperties as $property => $value) {\\n    $properties[\'property.\' . $property] = $value;\\n}\\n\\n$output = \'\';\\n\\nforeach ($activeitems as $key => $item) {\\n\\n    $fields = array();\\n    foreach ($item as $field => $value) {\\n        $value = is_array($value) ? implode(\'||\', $value) : $value; \\/\\/handle arrays (checkboxes, multiselects)\\n        if ($processTVs && isset($inputTvs[$field])) {\\n            if ($tv = $modx->getObject(\'modTemplateVar\', array(\'name\' => $inputTvs[$field][\'inputTV\']))) {\\n\\n            } else {\\n                $tv = $modx->newObject(\'modTemplateVar\');\\n                $tv->set(\'type\', $inputTvs[$field][\'inputTVtype\']);\\n            }\\n            $inputTV = $inputTvs[$field];\\n\\n            $mTypes = $modx->getOption(\'manipulatable_url_tv_output_types\', null, \'image,file\');\\n            \\/\\/don\'t manipulate any urls here\\n            $modx->setOption(\'manipulatable_url_tv_output_types\', \'\');\\n            $tv->set(\'default_text\', $value);\\n            $value = $tv->renderOutput($docid);\\n            \\/\\/set option back\\n            $modx->setOption(\'manipulatable_url_tv_output_types\', $mTypes);\\n            \\/\\/now manipulate urls\\n            if ($mediasource = $migx->getFieldSource($inputTV, $tv)) {\\n                $mTypes = explode(\',\', $mTypes);\\n                if (!empty($value) && in_array($tv->get(\'type\'), $mTypes)) {\\n                    \\/\\/$value = $mediasource->prepareOutputUrl($value);\\n                    $value = str_replace(\'\\/.\\/\', \'\\/\', $mediasource->prepareOutputUrl($value));\\n                }\\n            }\\n\\n        }\\n        $fields[$field] = $value;\\n\\n    }\\n\\n    $rowtpl = $tpl;\\n    \\/\\/get changing tpls from field\\n    if (substr($tpl, 0, 7) == \\"@FIELD:\\") {\\n        $tplField = substr($tpl, 7);\\n        $rowtpl = $fields[$tplField];\\n    }\\n\\n    if (!isset($template[$rowtpl])) {\\n        if (substr($rowtpl, 0, 6) == \\"@FILE:\\") {\\n            $template[$rowtpl] = file_get_contents($modx->config[\'base_path\'] . substr($rowtpl, 6));\\n        } elseif (substr($rowtpl, 0, 6) == \\"@CODE:\\") {\\n            $template[$rowtpl] = substr($tpl, 6);\\n        } elseif ($chunk = $modx->getObject(\'modChunk\', array(\'name\' => $rowtpl), true)) {\\n            $template[$rowtpl] = $chunk->getContent();\\n        } else {\\n            $template[$rowtpl] = false;\\n        }\\n    }\\n\\n    $fields = array_merge($fields, $properties);\\n\\n    if ($template[$rowtpl]) {\\n        $chunk = $modx->newObject(\'modChunk\');\\n        $chunk->setCacheable(false);\\n        $chunk->setContent($template[$rowtpl]);\\n        $output .= $chunk->process($fields);\\n\\n    } else {\\n        $output .= \'<pre>\' . print_r($fields, 1) . \'<\\/pre>\';\\n\\n    }\\n\\n\\n}\\n\\n\\nif (!empty($toPlaceholder)) {\\n    $modx->setPlaceholder($toPlaceholder, $output);\\n    return \'\';\\n}\\n\\nreturn $output;","locked":0,"properties":"a:0:{}","moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * getDayliMIGXrecord\\n *\\n * Copyright 2009-2011 by Bruno Perner <b.perner@gmx.de>\\n *\\n * getDayliMIGXrecord is free software; you can redistribute it and\\/or modify it\\n * under the terms of the GNU General Public License as published by the Free\\n * Software Foundation; either version 2 of the License, or (at your option) any\\n * later version.\\n *\\n * getDayliMIGXrecord is distributed in the hope that it will be useful, but WITHOUT ANY\\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License along with\\n * getDayliMIGXrecord; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\\n * Suite 330, Boston, MA 02111-1307 USA\\n *\\n * @package migx\\n *\\/\\n\\/**\\n * getDayliMIGXrecord\\n *\\n * display Items from outputvalue of TV with custom-TV-input-type MIGX or from other JSON-string for MODx Revolution \\n *\\n * @version 1.0\\n * @author Bruno Perner <b.perner@gmx.de>\\n * @copyright Copyright &copy; 2012\\n * @license http:\\/\\/www.gnu.org\\/licenses\\/old-licenses\\/gpl-2.0.html GNU General Public License\\n * version 2 or (at your option) any later version.\\n * @package migx\\n *\\/\\n\\n\\/*example: [[!getDayliMIGXrecord? &tvname=`myTV`&tpl=`@CODE:<img src=\\"[[+image]]\\"\\/>` &randomize=`1`]]*\\/\\n\\/* get default properties *\\/\\n\\n\\n$tvname = $modx->getOption(\'tvname\', $scriptProperties, \'\');\\n$tpl = $modx->getOption(\'tpl\', $scriptProperties, \'\');\\n$randomize = $modx->getOption(\'randomize\', $scriptProperties, false);\\n$where = $modx->getOption(\'where\', $scriptProperties, \'\');\\n$where = !empty($where) ? $modx->fromJSON($where) : array();\\n$sort = $modx->getOption(\'sort\', $scriptProperties, \'\');\\n$sort = !empty($sort) ? $modx->fromJSON($sort) : array();\\n$toPlaceholder = $modx->getOption(\'toPlaceholder\', $scriptProperties, false);\\n$docid = $modx->getOption(\'docid\', $scriptProperties, (isset($modx->resource) ? $modx->resource->get(\'id\') : 1));\\n$processTVs = $modx->getOption(\'processTVs\', $scriptProperties, \'1\');\\n\\n$migx = $modx->getService(\'migx\', \'Migx\', $modx->getOption(\'migx.core_path\', null, $modx->getOption(\'core_path\') . \'components\\/migx\\/\') . \'model\\/migx\\/\', $scriptProperties);\\nif (!($migx instanceof Migx))\\n    return \'\';\\n$migx->working_context = $modx->resource->get(\'context_key\');\\n\\nif (!empty($tvname)) {\\n    if ($tv = $modx->getObject(\'modTemplateVar\', array(\'name\' => $tvname))) {\\n\\n        \\/*\\n        *   get inputProperties\\n        *\\/\\n\\n\\n        $properties = $tv->get(\'input_properties\');\\n        $properties = isset($properties[\'formtabs\']) ? $properties : $tv->getProperties();\\n\\n        $migx->config[\'configs\'] = $properties[\'configs\'];\\n        $migx->loadConfigs();\\n        \\/\\/ get tabs from file or migx-config-table\\n        $formtabs = $migx->getTabs();\\n        if (empty($formtabs)) {\\n            \\/\\/try to get formtabs and its fields from properties\\n            $formtabs = $modx->fromJSON($properties[\'formtabs\']);\\n        }\\n\\n        \\/\\/$tv->setCacheable(false);\\n        \\/\\/$outputvalue = $tv->renderOutput($docid);\\n        \\n        $tvresource = $modx->getObject(\'modTemplateVarResource\', array(\\n            \'tmplvarid\' => $tv->get(\'id\'),\\n            \'contentid\' => $docid,\\n            ));\\n\\n\\n        $outputvalue = $tvresource->get(\'value\');\\n        \\n        \\/*\\n        *   get inputTvs \\n        *\\/\\n        $inputTvs = array();\\n        if (is_array($formtabs)) {\\n\\n            \\/\\/multiple different Forms\\n            \\/\\/ Note: use same field-names and inputTVs in all forms\\n            $inputTvs = $migx->extractInputTvs($formtabs);\\n        }\\n        $migx->source = $tv->getSource($migx->working_context, false);\\n\\n        if (empty($outputvalue)) {\\n            return \'\';\\n        }\\n\\n        $items = $modx->fromJSON($outputvalue);\\n\\n\\n        \\/\\/is there an active item for the current date?\\n        $activedate = $modx->getOption(\'activedate\', $scriptProperties, strftime(\'%Y\\/%m\\/%d\'));\\n        \\/\\/$activedate = $modx->getOption(\'activedate\', $_GET, strftime(\'%Y\\/%m\\/%d\'));\\n        $activewhere = array();\\n        $activewhere[\'activedate\'] = $activedate;\\n        $activewhere[\'activated\'] = \'1\';\\n        $activeitems = $migx->filterItems($activewhere, $items);\\n\\n        if (count($activeitems) == 0) {\\n\\n            $activeitems = array();\\n            \\/\\/ where filter\\n            if (is_array($where) && count($where) > 0) {\\n                $items = $migx->filterItems($where, $items);\\n            }\\n\\n            $tempitems = array();\\n            $count = count($items);\\n            $emptycount = 0;\\n            $latestdate = $activedate;\\n            $nextdate = strtotime($latestdate);\\n            foreach ($items as $item) {\\n                \\/\\/empty all dates and active-states which are older than today\\n                if (!empty($item[\'activedate\']) && $item[\'activedate\'] < $activedate) {\\n                    $item[\'activated\'] = \'0\';\\n                    $item[\'activedate\'] = \'\';\\n                }\\n                if (empty($item[\'activedate\'])) {\\n                    $emptycount++;\\n                }\\n                if ($item[\'activedate\'] > $latestdate) {\\n                    $latestdate = $item[\'activedate\'];\\n                    $nextdate = strtotime($latestdate) + (24 * 60 * 60);\\n                }\\n                if ($item[\'activedate\'] == $activedate) {\\n                    $item[\'activated\'] = \'1\';\\n                    $activeitems[] = $item;\\n                }\\n                $tempitems[] = $item;\\n            }\\n\\n            \\/\\/echo \'<pre>\' . print_r($tempitems, 1) . \'<\\/pre>\';\\n\\n            $items = $tempitems;\\n\\n\\n            \\/\\/are there more than half of all items with empty activedates\\n\\n            if ($emptycount >= $count \\/ 2) {\\n\\n                \\/\\/ sort items\\n                if (is_array($sort) && count($sort) > 0) {\\n                    $items = $migx->sortDbResult($items, $sort);\\n                }\\n                if (count($items) > 0) {\\n                    \\/\\/shuffle items\\n                    if ($randomize) {\\n                        shuffle($items);\\n                    }\\n                }\\n\\n                $tempitems = array();\\n                foreach ($items as $item) {\\n                    if (empty($item[\'activedate\'])) {\\n                        $item[\'activedate\'] = strftime(\'%Y\\/%m\\/%d\', $nextdate);\\n                        $nextdate = $nextdate + (24 * 60 * 60);\\n                        if ($item[\'activedate\'] == $activedate) {\\n                            $item[\'activated\'] = \'1\';\\n                            $activeitems[] = $item;\\n                        }\\n                    }\\n\\n                    $tempitems[] = $item;\\n                }\\n\\n                $items = $tempitems;\\n            }\\n\\n            \\/\\/$resource = $modx->getObject(\'modResource\', $docid);\\n            \\/\\/echo $modx->toJson($items);\\n            $sort = \'[{\\"sortby\\":\\"activedate\\"}]\';\\n            $items = $migx->sortDbResult($items, $modx->fromJson($sort));\\n\\n            \\/\\/echo \'<pre>\' . print_r($items, 1) . \'<\\/pre>\';\\n\\n            $tv->setValue($docid, $modx->toJson($items));\\n            $tv->save();\\n\\n        }\\n    }\\n\\n}\\n\\n\\n$properties = array();\\nforeach ($scriptProperties as $property => $value) {\\n    $properties[\'property.\' . $property] = $value;\\n}\\n\\n$output = \'\';\\n\\nforeach ($activeitems as $key => $item) {\\n\\n    $fields = array();\\n    foreach ($item as $field => $value) {\\n        $value = is_array($value) ? implode(\'||\', $value) : $value; \\/\\/handle arrays (checkboxes, multiselects)\\n        if ($processTVs && isset($inputTvs[$field])) {\\n            if ($tv = $modx->getObject(\'modTemplateVar\', array(\'name\' => $inputTvs[$field][\'inputTV\']))) {\\n\\n            } else {\\n                $tv = $modx->newObject(\'modTemplateVar\');\\n                $tv->set(\'type\', $inputTvs[$field][\'inputTVtype\']);\\n            }\\n            $inputTV = $inputTvs[$field];\\n\\n            $mTypes = $modx->getOption(\'manipulatable_url_tv_output_types\', null, \'image,file\');\\n            \\/\\/don\'t manipulate any urls here\\n            $modx->setOption(\'manipulatable_url_tv_output_types\', \'\');\\n            $tv->set(\'default_text\', $value);\\n            $value = $tv->renderOutput($docid);\\n            \\/\\/set option back\\n            $modx->setOption(\'manipulatable_url_tv_output_types\', $mTypes);\\n            \\/\\/now manipulate urls\\n            if ($mediasource = $migx->getFieldSource($inputTV, $tv)) {\\n                $mTypes = explode(\',\', $mTypes);\\n                if (!empty($value) && in_array($tv->get(\'type\'), $mTypes)) {\\n                    \\/\\/$value = $mediasource->prepareOutputUrl($value);\\n                    $value = str_replace(\'\\/.\\/\', \'\\/\', $mediasource->prepareOutputUrl($value));\\n                }\\n            }\\n\\n        }\\n        $fields[$field] = $value;\\n\\n    }\\n\\n    $rowtpl = $tpl;\\n    \\/\\/get changing tpls from field\\n    if (substr($tpl, 0, 7) == \\"@FIELD:\\") {\\n        $tplField = substr($tpl, 7);\\n        $rowtpl = $fields[$tplField];\\n    }\\n\\n    if (!isset($template[$rowtpl])) {\\n        if (substr($rowtpl, 0, 6) == \\"@FILE:\\") {\\n            $template[$rowtpl] = file_get_contents($modx->config[\'base_path\'] . substr($rowtpl, 6));\\n        } elseif (substr($rowtpl, 0, 6) == \\"@CODE:\\") {\\n            $template[$rowtpl] = substr($tpl, 6);\\n        } elseif ($chunk = $modx->getObject(\'modChunk\', array(\'name\' => $rowtpl), true)) {\\n            $template[$rowtpl] = $chunk->getContent();\\n        } else {\\n            $template[$rowtpl] = false;\\n        }\\n    }\\n\\n    $fields = array_merge($fields, $properties);\\n\\n    if ($template[$rowtpl]) {\\n        $chunk = $modx->newObject(\'modChunk\');\\n        $chunk->setCacheable(false);\\n        $chunk->setContent($template[$rowtpl]);\\n        $output .= $chunk->process($fields);\\n\\n    } else {\\n        $output .= \'<pre>\' . print_r($fields, 1) . \'<\\/pre>\';\\n\\n    }\\n\\n\\n}\\n\\n\\nif (!empty($toPlaceholder)) {\\n    $modx->setPlaceholder($toPlaceholder, $output);\\n    return \'\';\\n}\\n\\nreturn $output;"}',
);