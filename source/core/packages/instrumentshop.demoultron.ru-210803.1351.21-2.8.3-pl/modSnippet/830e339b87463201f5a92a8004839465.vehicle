<?php return array (
  'preserve_keys' => true,
  'update_object' => true,
  'vehicle_package' => 'transport',
  'vehicle_class' => 'xPDOObjectVehicle',
  'guid' => 'b158f9ffd646550d993fac2d9e49189f',
  'package' => 'modx',
  'class' => 'modSnippet',
  'signature' => '830e339b87463201f5a92a8004839465',
  'native_key' => 51,
  'object' => '{"id":51,"source":0,"property_preprocess":0,"name":"FormItSaveForm","description":"Custom hook for FormIt to save the form.","editor_type":0,"category":11,"cache_type":0,"snippet":"\\/**\\n * FormIt\\n *\\n * Copyright 2011-12 by SCHERP Ontwikkeling <info@scherpontwikkeling.nl>\\n * Copyright 2015 by Wieger Sloot <modx@sterc.nl>\\n *\\n * FormIt is free software; you can redistribute it and\\/or modify it\\n * under the terms of the GNU General Public License as published by the Free\\n * Software Foundation; either version 2 of the License, or (at your option) any\\n * later version.\\n *\\n * FormIt is distributed in the hope that it will be useful, but WITHOUT ANY\\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License along with\\n * FormIt; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\\n * Suite 330, Boston, MA 02111-1307 USA\\n *\\n * @package formit\\n *\\/\\n\\/**\\n * A custom FormIt hook for saving filled-in forms. - Based on FormSave\\n *\\n * @var modX $modx\\n * @var array $scriptProperties\\n * @var FormIt $formit\\n * @var fiHooks $hook\\n * \\n * @package formit\\n *\\/\\n\\/* setup default properties *\\/\\n$values = $hook->getValues();\\n$formName = $modx->getOption(\'formName\', $formit->config, \'form-\'.$modx->resource->get(\'id\'));\\n\\/\\/ process formName. Pick a value from the form\\n\\/\\/ Inspired from the email\'s hook of formit (fihooks.class.php)\\nif (is_string($formName)) {\\n    foreach ($fields as $k => $v) {\\n        if (is_scalar($k) && is_scalar($v)) {\\n            $formName = str_replace(\'[[+\'.$k.\']]\',$v,$formName);\\n        }\\n    }\\n}\\n\\n$formEncrypt = $modx->getOption(\'formEncrypt\', $formit->config, false);\\n$formFields = $modx->getOption(\'formFields\', $formit->config, false);\\n$fieldNames = $modx->getOption(\'fieldNames\', $formit->config, false);\\n$updateSavedForm = $modx->getOption(\'updateSavedForm\', $formit->config, false); \\/\\/ true, false, \'1\', \'0\', or \'values\'\\n\\/\\/ In order to use update process, you need to provide the hash key to the user somehow\\n\\/\\/ Usually with [[!FormItRetriever]] to populate this form field:\\n$formHashKeyField = $modx->getOption(\'savedFormHashKeyField\', $formit->config, \'savedFormHashKey\');\\n\\/\\/ Disable if you want to use the session_id() in your hash, like FormIt does\\n\\/\\/ WARNING: this can cause potential hash key collisions and overwriting of the wrong form record!!\\n$formHashKeyRandom = $modx->getOption(\'formHashKeyRandom\', $formit->config, true);\\n\\/\\/ process formHashKeyField into variable for later use\\n$formHashKey = (isset($values[$formHashKeyField])) ? (string) $values[$formHashKeyField] : \'\';\\n\\/\\/ our hashing methods return 32 chars\\nif (strlen($formHashKey) !== 32) $formHashKey = \'\';\\nunset($values[$formHashKeyField]);\\n\\nif ($formFields) {\\n    $formFields = explode(\',\', $formFields);\\n    foreach($formFields as $k => $v) {\\n        $formFields[$k] = trim($v);\\n    }\\n}\\n\\/\\/ Build the data array\\n$dataArray = array();\\nif ($formFields) {\\n    foreach ($formFields as $field) {\\n        $fieldValue = isset($values[$field]) ? $values[$field] : \'\';\\n        \\/\\/ When field is file field, value is an array\\n        if (is_array($fieldValue) && isset($fieldValue[\'tmp_name\'], $fieldValue[\'name\'])) {\\n            $fieldValue = $fieldValue[\'name\'];\\n        }\\n        $dataArray[$field] = $fieldValue;\\n    }\\n} else {\\n    $dataArray = $values;\\n}\\n\\/\\/ Change the fieldnames\\nif ($fieldNames) {\\n    $newDataArray = array();\\n    $fieldLabels = array();\\n    $formFieldNames = explode(\',\', $fieldNames);\\n    foreach ($formFieldNames as $formFieldName) {\\n        $parts = explode(\'==\', $formFieldName);\\n        $fieldLabels[trim($parts[0])] = trim($parts[1]);\\n    }\\n    foreach ($dataArray as $key => $value) {\\n        if ($fieldLabels[$key]) {\\n            $labelKey = $fieldLabels[$key];\\n            if (array_key_exists($labelKey, $newDataArray)) {\\n                $labelKey .= \' (\'.$key.\')\';\\n            }\\n            $newDataArray[$labelKey] = $value;\\n        } else {\\n            $newDataArray[$key] = $value;\\n        }\\n    }\\n    $dataArray = $newDataArray;\\n}\\n\\/\\/ We only enter update mode if we already have a valid formHashKey (tested above)\\n\\/\\/ AND the updateSavedForm param was set to a truth-y value.\\n$mode = ($updateSavedForm && $formHashKey) ? \'update\' : \'create\';\\n\\/\\/ Create\\/get obj\\n$newForm = null;\\nif ($mode === \'update\') {\\n    $newForm = $modx->getObject(\'FormItForm\', array(\'hash\' => $formHashKey));\\n}\\nif ($newForm === null) {\\n    $newForm = $modx->newObject(\'FormItForm\');\\n}\\n\\n\\/\\/ Array from which to populate form record\\n$newFormArray = array();\\n\\n\\/\\/ Handle encryption\\n$encryptionType = 1;\\nif ($formEncrypt) {\\n    $dataArray = $newForm->encrypt($modx->toJSON($dataArray));\\n    \\/\\/ Only set encryption type if encryption is successful\\n    if ($dataArray) {\\n        \\/\\/ Set encryption type to 2 (openssl)\\n        $encryptionType = 2;\\n    }\\n} else {\\n    $dataArray = $modx->toJSON($dataArray);\\n}\\n\\n\\/\\/ Create new hash key on create mode, and handle invalid hash keys. \\nif ($mode === \'create\') {\\n    $formHashKey = ($formHashKeyRandom) ? $newForm->generatePseudoRandomHash() : pathinfo($formit->getStoreKey(), PATHINFO_BASENAME);\\n}\\n\\n\\/\\/ Special case: if updateSavedForm has the flag \'values\' we only merge in\\n\\/\\/ the form values, not the other stuff\\nif ($mode === \'update\' && $updateSavedForm === \'values\') {\\n    $newFormArray = $newForm->toArray();\\n    $newFormArray = array_merge($newFormArray, array(\\n        \'values\' => $dataArray,\\n        \'encryption_type\' => $encryptionType,\\n    ));\\n} else {\\n    \\/\\/ In all other cases, we overwrite the record completely!\\n    \\/\\/ In create mode we must save the hash. In update mode, the \\n    \\/\\/ formHashKey will be valid so we can also save it, again.\\n    $newFormArray = array(\\n        \'form\' => $formName,\\n        \'date\' => time(),\\n        \'values\' => $dataArray,\\n        \'ip\' => $modx->getOption(\'REMOTE_ADDR\', $_SERVER, \'\'),\\n        \'context_key\' => $modx->resource->get(\'context_key\'),\\n        \'encrypted\' => $formEncrypt,\\n        \'encryption_type\' => $encryptionType,\\n        \'hash\' => $formHashKey,\\n    );\\n}\\n\\/\\/ Convert to object\\n$newForm->fromArray($newFormArray);\\n\\/\\/ Attempt to save\\nif (!$newForm->save()) {\\n    $modx->log(modX::LOG_LEVEL_ERROR, \'[FormItSaveForm] An error occurred while trying to save the submitted form: \' . print_r($newForm->toArray(), true));\\n    return false;\\n}\\n\\/\\/ Pass the hash and form data back to the user\\n$hook->setValue(\'savedForm\', $newForm->toArray());\\n$hook->setValue($formHashKeyField, $newForm->get(\'hash\'));\\nreturn true;","locked":0,"properties":"a:0:{}","moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * FormIt\\n *\\n * Copyright 2011-12 by SCHERP Ontwikkeling <info@scherpontwikkeling.nl>\\n * Copyright 2015 by Wieger Sloot <modx@sterc.nl>\\n *\\n * FormIt is free software; you can redistribute it and\\/or modify it\\n * under the terms of the GNU General Public License as published by the Free\\n * Software Foundation; either version 2 of the License, or (at your option) any\\n * later version.\\n *\\n * FormIt is distributed in the hope that it will be useful, but WITHOUT ANY\\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License along with\\n * FormIt; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\\n * Suite 330, Boston, MA 02111-1307 USA\\n *\\n * @package formit\\n *\\/\\n\\/**\\n * A custom FormIt hook for saving filled-in forms. - Based on FormSave\\n *\\n * @var modX $modx\\n * @var array $scriptProperties\\n * @var FormIt $formit\\n * @var fiHooks $hook\\n * \\n * @package formit\\n *\\/\\n\\/* setup default properties *\\/\\n$values = $hook->getValues();\\n$formName = $modx->getOption(\'formName\', $formit->config, \'form-\'.$modx->resource->get(\'id\'));\\n\\/\\/ process formName. Pick a value from the form\\n\\/\\/ Inspired from the email\'s hook of formit (fihooks.class.php)\\nif (is_string($formName)) {\\n    foreach ($fields as $k => $v) {\\n        if (is_scalar($k) && is_scalar($v)) {\\n            $formName = str_replace(\'[[+\'.$k.\']]\',$v,$formName);\\n        }\\n    }\\n}\\n\\n$formEncrypt = $modx->getOption(\'formEncrypt\', $formit->config, false);\\n$formFields = $modx->getOption(\'formFields\', $formit->config, false);\\n$fieldNames = $modx->getOption(\'fieldNames\', $formit->config, false);\\n$updateSavedForm = $modx->getOption(\'updateSavedForm\', $formit->config, false); \\/\\/ true, false, \'1\', \'0\', or \'values\'\\n\\/\\/ In order to use update process, you need to provide the hash key to the user somehow\\n\\/\\/ Usually with [[!FormItRetriever]] to populate this form field:\\n$formHashKeyField = $modx->getOption(\'savedFormHashKeyField\', $formit->config, \'savedFormHashKey\');\\n\\/\\/ Disable if you want to use the session_id() in your hash, like FormIt does\\n\\/\\/ WARNING: this can cause potential hash key collisions and overwriting of the wrong form record!!\\n$formHashKeyRandom = $modx->getOption(\'formHashKeyRandom\', $formit->config, true);\\n\\/\\/ process formHashKeyField into variable for later use\\n$formHashKey = (isset($values[$formHashKeyField])) ? (string) $values[$formHashKeyField] : \'\';\\n\\/\\/ our hashing methods return 32 chars\\nif (strlen($formHashKey) !== 32) $formHashKey = \'\';\\nunset($values[$formHashKeyField]);\\n\\nif ($formFields) {\\n    $formFields = explode(\',\', $formFields);\\n    foreach($formFields as $k => $v) {\\n        $formFields[$k] = trim($v);\\n    }\\n}\\n\\/\\/ Build the data array\\n$dataArray = array();\\nif ($formFields) {\\n    foreach ($formFields as $field) {\\n        $fieldValue = isset($values[$field]) ? $values[$field] : \'\';\\n        \\/\\/ When field is file field, value is an array\\n        if (is_array($fieldValue) && isset($fieldValue[\'tmp_name\'], $fieldValue[\'name\'])) {\\n            $fieldValue = $fieldValue[\'name\'];\\n        }\\n        $dataArray[$field] = $fieldValue;\\n    }\\n} else {\\n    $dataArray = $values;\\n}\\n\\/\\/ Change the fieldnames\\nif ($fieldNames) {\\n    $newDataArray = array();\\n    $fieldLabels = array();\\n    $formFieldNames = explode(\',\', $fieldNames);\\n    foreach ($formFieldNames as $formFieldName) {\\n        $parts = explode(\'==\', $formFieldName);\\n        $fieldLabels[trim($parts[0])] = trim($parts[1]);\\n    }\\n    foreach ($dataArray as $key => $value) {\\n        if ($fieldLabels[$key]) {\\n            $labelKey = $fieldLabels[$key];\\n            if (array_key_exists($labelKey, $newDataArray)) {\\n                $labelKey .= \' (\'.$key.\')\';\\n            }\\n            $newDataArray[$labelKey] = $value;\\n        } else {\\n            $newDataArray[$key] = $value;\\n        }\\n    }\\n    $dataArray = $newDataArray;\\n}\\n\\/\\/ We only enter update mode if we already have a valid formHashKey (tested above)\\n\\/\\/ AND the updateSavedForm param was set to a truth-y value.\\n$mode = ($updateSavedForm && $formHashKey) ? \'update\' : \'create\';\\n\\/\\/ Create\\/get obj\\n$newForm = null;\\nif ($mode === \'update\') {\\n    $newForm = $modx->getObject(\'FormItForm\', array(\'hash\' => $formHashKey));\\n}\\nif ($newForm === null) {\\n    $newForm = $modx->newObject(\'FormItForm\');\\n}\\n\\n\\/\\/ Array from which to populate form record\\n$newFormArray = array();\\n\\n\\/\\/ Handle encryption\\n$encryptionType = 1;\\nif ($formEncrypt) {\\n    $dataArray = $newForm->encrypt($modx->toJSON($dataArray));\\n    \\/\\/ Only set encryption type if encryption is successful\\n    if ($dataArray) {\\n        \\/\\/ Set encryption type to 2 (openssl)\\n        $encryptionType = 2;\\n    }\\n} else {\\n    $dataArray = $modx->toJSON($dataArray);\\n}\\n\\n\\/\\/ Create new hash key on create mode, and handle invalid hash keys. \\nif ($mode === \'create\') {\\n    $formHashKey = ($formHashKeyRandom) ? $newForm->generatePseudoRandomHash() : pathinfo($formit->getStoreKey(), PATHINFO_BASENAME);\\n}\\n\\n\\/\\/ Special case: if updateSavedForm has the flag \'values\' we only merge in\\n\\/\\/ the form values, not the other stuff\\nif ($mode === \'update\' && $updateSavedForm === \'values\') {\\n    $newFormArray = $newForm->toArray();\\n    $newFormArray = array_merge($newFormArray, array(\\n        \'values\' => $dataArray,\\n        \'encryption_type\' => $encryptionType,\\n    ));\\n} else {\\n    \\/\\/ In all other cases, we overwrite the record completely!\\n    \\/\\/ In create mode we must save the hash. In update mode, the \\n    \\/\\/ formHashKey will be valid so we can also save it, again.\\n    $newFormArray = array(\\n        \'form\' => $formName,\\n        \'date\' => time(),\\n        \'values\' => $dataArray,\\n        \'ip\' => $modx->getOption(\'REMOTE_ADDR\', $_SERVER, \'\'),\\n        \'context_key\' => $modx->resource->get(\'context_key\'),\\n        \'encrypted\' => $formEncrypt,\\n        \'encryption_type\' => $encryptionType,\\n        \'hash\' => $formHashKey,\\n    );\\n}\\n\\/\\/ Convert to object\\n$newForm->fromArray($newFormArray);\\n\\/\\/ Attempt to save\\nif (!$newForm->save()) {\\n    $modx->log(modX::LOG_LEVEL_ERROR, \'[FormItSaveForm] An error occurred while trying to save the submitted form: \' . print_r($newForm->toArray(), true));\\n    return false;\\n}\\n\\/\\/ Pass the hash and form data back to the user\\n$hook->setValue(\'savedForm\', $newForm->toArray());\\n$hook->setValue($formHashKeyField, $newForm->get(\'hash\'));\\nreturn true;"}',
);